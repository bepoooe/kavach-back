{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://kavach-trial/./src/utils/privacy.ts","webpack://kavach-trial/webpack/bootstrap","webpack://kavach-trial/webpack/runtime/define property getters","webpack://kavach-trial/webpack/runtime/hasOwnProperty shorthand","webpack://kavach-trial/webpack/runtime/make namespace object","webpack://kavach-trial/./src/background/index.ts"],"sourcesContent":["export class TrustScoreCalculator {\n    static calculateScore(trackers, privacyRisks = []) {\n        let score = 100;\n        // Deduct points for trackers\n        const trackerPenalty = Math.min(trackers.length * 5, 40);\n        score -= trackerPenalty;\n        // Deduct points for high-risk trackers\n        const highRiskTrackers = trackers.filter(t => ['advertising', 'social', 'analytics'].includes(t.category));\n        score -= highRiskTrackers.length * 3;\n        // Deduct points for privacy policy risks\n        score -= Math.min(privacyRisks.length * 8, 30);\n        return Math.max(0, Math.min(100, score));\n    }\n}\nexport class PrivacyPolicyAnalyzer {\n    static async analyzePolicy(url) {\n        try {\n            console.log('Analyzing privacy policy for:', url);\n            const response = await fetch(`${this.API_BASE_URL}/privacy-policy/analyze`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({ url }),\n                // Add timeout for Chrome extension\n                signal: AbortSignal.timeout(30000) // 30 second timeout\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(() => ({}));\n                throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);\n            }\n            const result = await response.json();\n            if (!result.success) {\n                throw new Error(result.error || 'Analysis failed');\n            }\n            console.log('Privacy policy analysis completed:', result.data);\n            return result.data;\n        }\n        catch (error) {\n            console.error('Privacy policy analysis failed:', error);\n            // Return enhanced fallback data based on error type\n            const fallbackAnalysis = {\n                score: 50,\n                risks: ['Unable to analyze privacy policy - please review manually'],\n                summary: 'Privacy policy analysis failed. This could be due to network issues, missing privacy policy, or service unavailability.',\n                dataSharing: [],\n                recommendations: [\n                    'Review the privacy policy manually',\n                    'Check if the website has a privacy policy',\n                    'Contact the website for clarification on data practices'\n                ],\n                complianceStatus: {\n                    gdpr: 'unclear',\n                    ccpa: 'unclear',\n                    coppa: 'unclear'\n                },\n                dataRetention: 'Unable to determine data retention policy',\n                userRights: [],\n                thirdPartySharing: true, // Assume worst case\n                cookiePolicy: 'Unable to determine cookie policy',\n                policyMetadata: {\n                    url: null,\n                    title: 'Privacy Policy Analysis Failed',\n                    analyzedAt: new Date().toISOString(),\n                    error: error instanceof Error ? error.message : 'Unknown error'\n                }\n            };\n            // Provide more specific feedback based on error type\n            if (error instanceof Error) {\n                if (error.message.includes('timeout') || error.message.includes('AbortError')) {\n                    fallbackAnalysis.summary = 'Privacy policy analysis timed out. The website may be slow to respond.';\n                    fallbackAnalysis.recommendations = [\n                        'Try again in a few minutes',\n                        'Check your internet connection',\n                        'Review the privacy policy manually'\n                    ];\n                }\n                else if (error.message.includes('404') || error.message.includes('not found')) {\n                    fallbackAnalysis.summary = 'No privacy policy was found on this website.';\n                    fallbackAnalysis.score = 30; // Lower score for missing privacy policy\n                    fallbackAnalysis.risks = [\n                        'No privacy policy found',\n                        'Data practices unclear',\n                        'User rights undefined'\n                    ];\n                    fallbackAnalysis.recommendations = [\n                        'Contact the website to request their privacy policy',\n                        'Avoid sharing personal information',\n                        'Consider the privacy implications of using this site'\n                    ];\n                }\n                else if (error.message.includes('network') || error.message.includes('fetch')) {\n                    fallbackAnalysis.summary = 'Unable to connect to privacy analysis service.';\n                    fallbackAnalysis.recommendations = [\n                        'Check your internet connection',\n                        'Try again later',\n                        'Review the privacy policy manually'\n                    ];\n                }\n            }\n            return fallbackAnalysis;\n        }\n    }\n    /**\n     * Find privacy policy URL for a website\n     */\n    static async findPrivacyPolicyUrl(url) {\n        try {\n            const response = await fetch(`${this.API_BASE_URL}/privacy-policy/find?url=${encodeURIComponent(url)}`, {\n                method: 'GET',\n                signal: AbortSignal.timeout(10000) // 10 second timeout\n            });\n            if (!response.ok) {\n                return null;\n            }\n            const result = await response.json();\n            return result.success ? result.data.policyUrl : null;\n        }\n        catch (error) {\n            console.error('Failed to find privacy policy URL:', error);\n            return null;\n        }\n    }\n}\n// Production Render API endpoint\nPrivacyPolicyAnalyzer.API_BASE_URL = process.env.NODE_ENV === 'production'\n    ? 'https://kavach-hackolution.onrender.com/api'\n    : 'https://kavach-hackolution.onrender.com/api'; // Use production API for both dev and prod\nexport const commonTrackers = {\n    'doubleclick.net': { category: 'advertising', name: 'Google DoubleClick' },\n    'googletagmanager.com': { category: 'analytics', name: 'Google Tag Manager' },\n    'facebook.com': { category: 'social', name: 'Facebook Pixel' },\n    'google-analytics.com': { category: 'analytics', name: 'Google Analytics' },\n    'connect.facebook.net': { category: 'social', name: 'Facebook Connect' },\n    'amazon-adsystem.com': { category: 'advertising', name: 'Amazon Advertising' },\n    'twitter.com': { category: 'social', name: 'Twitter Analytics' },\n    'linkedin.com': { category: 'social', name: 'LinkedIn Insights' }\n};\nexport class OptOutManager {\n    static getOptOutStrategy(domain) {\n        // Find matching strategy for domain or subdomain\n        const strategies = Object.keys(this.OPT_OUT_STRATEGIES);\n        const matchingStrategy = strategies.find(strategyDomain => domain.includes(strategyDomain) || strategyDomain.includes(domain));\n        return matchingStrategy ? this.OPT_OUT_STRATEGIES[matchingStrategy] : null;\n    }\n    static getUniversalOptOutCookies() {\n        return [\n            'gdpr_consent=false',\n            'ccpa_optout=true',\n            'privacy_optout=true',\n            'cookie_consent=rejected',\n            'tracking_consent=false',\n            'analytics_consent=false',\n            'marketing_consent=false',\n            'personalization_consent=false',\n            'advertising_consent=false',\n            'functional_consent=false',\n            'performance_consent=false',\n            'social_media_consent=false',\n            'opt_out=true',\n            'privacy_settings=all_rejected',\n            'consent_mode=opt_out',\n            'do_not_track=1',\n            'user_consent_status=rejected',\n            // OneTrust specific\n            'OptanonConsent=',\n            'OptanonAlertBoxClosed=',\n            // Cookiebot specific\n            'CookieConsent=no',\n            // TrustArc specific\n            'notice_behavior=implied,eu',\n            'notice_gdpr_prefs=0,1,2,3:',\n            // Quantcast specific\n            'euconsent-v2=',\n            // Generic IAB consent\n            'gdpr=1',\n            'gdpr_consent=',\n            // Site-specific patterns\n            'cookies_accepted=false',\n            'accept_cookies=no',\n            'cookie_policy_accepted=false',\n            'data_processing_consent=false'\n        ];\n    }\n    static getUniversalOptOutSelectors() {\n        return [\n            // Generic opt-out buttons\n            'button[data-testid*=\"reject\"]',\n            'button[data-testid*=\"decline\"]',\n            'button[data-testid*=\"opt-out\"]',\n            'button[class*=\"reject\"]',\n            'button[class*=\"decline\"]',\n            'button[class*=\"opt-out\"]',\n            'a[href*=\"opt-out\"]',\n            'a[href*=\"unsubscribe\"]',\n            'a[href*=\"privacy-settings\"]',\n            // OneTrust CMP\n            '#onetrust-reject-all-handler',\n            '#onetrust-pc-btn-handler',\n            '.optanon-category-2',\n            '.optanon-category-3',\n            '.optanon-category-4',\n            // Cookiebot CMP\n            '#CybotCookiebotDialogBodyButtonDecline',\n            '#CybotCookiebotDialogBodyLevelButtonLevelOptinDeclineAll',\n            // TrustArc CMP\n            '#truste-consent-required',\n            '.truste-button-2',\n            // Quantcast CMP\n            '.qc-cmp2-summary-buttons > button:last-child',\n            '.qc-cmp2-toggle-switch',\n            // Generic consent management\n            '[data-cy*=\"reject\"]',\n            '[data-cy*=\"decline\"]',\n            '[data-cy=\"manage-consent-reject-all\"]',\n            '[data-testid=\"consent-reject-all\"]',\n            '.sp_choice_type_REJECT_ALL',\n            // Common cookie banner patterns\n            '.cookie-banner button[data-role=\"reject\"]',\n            '.gdpr-banner .reject-all',\n            '.consent-manager .decline-all',\n            '.privacy-banner .opt-out',\n            // Language-specific patterns\n            'button:contains(\"Reject All\")',\n            'button:contains(\"Decline All\")',\n            'button:contains(\"Opt Out\")',\n            'button:contains(\"Refuse All\")',\n            'button:contains(\"Deny All\")',\n            'button:contains(\"No Thanks\")',\n            'button:contains(\"Disagree\")',\n            // Logout buttons\n            'a[href*=\"logout\"]',\n            'a[href*=\"signout\"]',\n            'a[href*=\"sign-out\"]',\n            'button[data-testid*=\"logout\"]',\n            'button[data-testid*=\"signout\"]',\n            '.logout', '.signout', '.sign-out'\n        ];\n    }\n    static getTrackingDomainsToBlock() {\n        return [\n            // Google tracking\n            'google-analytics.com',\n            'googletagmanager.com',\n            'doubleclick.net',\n            'googlesyndication.com',\n            'googleadservices.com',\n            'gstatic.com',\n            // Facebook/Meta tracking  \n            'facebook.com',\n            'facebook.net',\n            'connect.facebook.net',\n            // Amazon tracking\n            'amazon-adsystem.com',\n            'amazonpay.com',\n            // Microsoft tracking\n            'bing.com',\n            'microsoft.com',\n            'live.com',\n            // Social media tracking\n            'twitter.com',\n            'linkedin.com',\n            'pinterest.com',\n            'tiktok.com',\n            'snapchat.com',\n            // Analytics platforms\n            'mixpanel.com',\n            'segment.com',\n            'amplitude.com',\n            'hotjar.com',\n            'fullstory.com',\n            'logrocket.com',\n            'mouseflow.com',\n            'crazyegg.com',\n            'optimizely.com',\n            // Ad networks\n            'criteo.com',\n            'outbrain.com',\n            'taboola.com',\n            'pubmatic.com',\n            'rubiconproject.com',\n            'openx.com',\n            'adsystem.com'\n        ];\n    }\n}\n// Website-specific opt-out mechanisms\nOptOutManager.OPT_OUT_STRATEGIES = {\n    'google.com': {\n        cookiesToSet: [\n            'CONSENT=PENDING+999',\n            'NID=; expires=Thu, 01 Jan 1970 00:00:00 GMT',\n            'ANID=; expires=Thu, 01 Jan 1970 00:00:00 GMT'\n        ],\n        selectors: ['[data-testid=\"reject-all\"]', '.QS5gu'],\n        logoutUrl: 'https://accounts.google.com/logout'\n    },\n    'facebook.com': {\n        cookiesToSet: [\n            'dpr=; expires=Thu, 01 Jan 1970 00:00:00 GMT',\n            'wd=; expires=Thu, 01 Jan 1970 00:00:00 GMT'\n        ],\n        selectors: ['[data-testid=\"cookie-policy-manage-dialog-decline-button\"]'],\n        logoutUrl: 'https://www.facebook.com/logout.php'\n    },\n    'amazon.com': {\n        cookiesToSet: [\n            'ad-privacy=0',\n            'csm-hit=; expires=Thu, 01 Jan 1970 00:00:00 GMT'\n        ],\n        selectors: ['[data-cy=\"sp_choice_type_REJECT_ALL\"]'],\n        logoutUrl: 'https://www.amazon.com/gp/flex/sign-out.html'\n    },\n    'twitter.com': {\n        cookiesToSet: [\n            'personalization_id=; expires=Thu, 01 Jan 1970 00:00:00 GMT',\n            'guest_id=; expires=Thu, 01 Jan 1970 00:00:00 GMT'\n        ],\n        selectors: ['[data-testid=\"decline\"]'],\n        logoutUrl: 'https://twitter.com/logout'\n    },\n    'linkedin.com': {\n        cookiesToSet: [\n            'UserMatchHistory=; expires=Thu, 01 Jan 1970 00:00:00 GMT',\n            'AnalyticsSyncHistory=; expires=Thu, 01 Jan 1970 00:00:00 GMT'\n        ],\n        selectors: ['[data-tracking-control-name=\"consent-banner_decline-all\"]'],\n        logoutUrl: 'https://www.linkedin.com/uas/logout'\n    },\n    'youtube.com': {\n        cookiesToSet: [\n            'CONSENT=PENDING+999',\n            'VISITOR_INFO1_LIVE=; expires=Thu, 01 Jan 1970 00:00:00 GMT'\n        ],\n        selectors: ['[aria-label=\"Reject all\"]', '[data-testid=\"reject-all-button\"]'],\n        logoutUrl: 'https://accounts.google.com/logout'\n    },\n    'instagram.com': {\n        cookiesToSet: [\n            'ig_nrcb=; expires=Thu, 01 Jan 1970 00:00:00 GMT',\n            'csrftoken=; expires=Thu, 01 Jan 1970 00:00:00 GMT'\n        ],\n        selectors: ['[data-testid=\"cookie-banner-decline\"]'],\n        logoutUrl: 'https://www.instagram.com/accounts/logout/'\n    }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { TrustScoreCalculator, commonTrackers } from '../utils/privacy';\nclass BackgroundService {\n    constructor() {\n        this.siteData = new Map();\n        this.blockedRequests = new Map();\n        this.privacyPolicyUrls = new Map();\n        console.log('üöÄ Kavach Background Service starting...');\n        this.setupRequestBlocking();\n        this.setupTabListeners();\n        this.setupMessageListeners();\n        console.log('‚úÖ Kavach Background Service initialized');\n    }\n    safeParseURL(url) {\n        try {\n            if (!url || typeof url !== 'string') {\n                console.warn('‚ùå Invalid URL input:', url);\n                return null;\n            }\n            return new URL(url);\n        }\n        catch (error) {\n            console.warn('‚ùå Failed to parse URL:', url, error);\n            return null;\n        }\n    }\n    getDomainFromURL(url) {\n        const parsedUrl = this.safeParseURL(url);\n        return parsedUrl ? parsedUrl.hostname : null;\n    }\n    setupRequestBlocking() {\n        console.log('üõ°Ô∏è Kavach: Setting up request blocking...');\n        // Monitor web requests to track third-party requests\n        chrome.webRequest.onBeforeRequest.addListener((details) => {\n            console.log('üåê Request detected:', details.url, 'Type:', details.type, 'Initiator:', details.initiator);\n            if (details.type === 'main_frame')\n                return {};\n            const url = this.safeParseURL(details.url);\n            const initiatorUrl = details.initiator ? this.safeParseURL(details.initiator) : null;\n            if (url && initiatorUrl && url.hostname !== initiatorUrl.hostname) {\n                console.log('üö® Third-party request:', url.hostname, 'from', initiatorUrl.hostname);\n                this.trackThirdPartyRequest(initiatorUrl.hostname, url.hostname, details.type);\n            }\n            return {};\n        }, { urls: ['<all_urls>'] }, ['requestBody']);\n    }\n    setupTabListeners() {\n        console.log('üëÇ Setting up tab listeners...');\n        chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n            if (changeInfo.status === 'complete' && tab.url && this.isValidHttpUrl(tab.url)) {\n                console.log('üìÑ Tab completed loading:', tab.url);\n                this.initializeSiteData(tab.url);\n            }\n        });\n        // Also listen for tab activation to ensure we have data for active tabs\n        chrome.tabs.onActivated.addListener(async (activeInfo) => {\n            try {\n                const tab = await chrome.tabs.get(activeInfo.tabId);\n                if (tab.url && this.isValidHttpUrl(tab.url)) {\n                    console.log('üîÑ Tab activated:', tab.url);\n                    this.initializeSiteData(tab.url);\n                }\n            }\n            catch (error) {\n                console.log('‚ùå Error getting active tab:', error);\n            }\n        });\n    }\n    isValidHttpUrl(url) {\n        try {\n            const parsedUrl = new URL(url);\n            return parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:';\n        }\n        catch {\n            return false;\n        }\n    }\n    trackThirdPartyRequest(sourceDomain, trackerDomain, requestType) {\n        console.log('üìä Tracking third-party request:', { sourceDomain, trackerDomain, requestType });\n        let siteData = this.siteData.get(sourceDomain);\n        if (!siteData) {\n            console.log('‚ùå No site data found for:', sourceDomain, '- Creating new site data');\n            // Initialize site data for this domain\n            this.initializeSiteDataForDomain(sourceDomain);\n            siteData = this.siteData.get(sourceDomain);\n            if (!siteData) {\n                console.log('‚ùå Failed to create site data for:', sourceDomain);\n                return;\n            }\n        }\n        const existingTracker = siteData.trackers.find(t => t.domain === trackerDomain);\n        if (existingTracker) {\n            existingTracker.count++;\n            console.log('üìà Updated tracker count:', trackerDomain, existingTracker.count);\n        }\n        else {\n            const trackerInfo = commonTrackers[trackerDomain];\n            const newTracker = {\n                domain: trackerDomain,\n                count: 1,\n                category: trackerInfo?.category || 'unknown',\n                blocked: this.isTrackerBlocked(trackerDomain)\n            };\n            siteData.trackers.push(newTracker);\n            console.log('üÜï New tracker detected:', newTracker);\n        }\n        // Recalculate trust score\n        const oldScore = siteData.trustScore;\n        siteData.trustScore = TrustScoreCalculator.calculateScore(siteData.trackers);\n        console.log('üéØ Trust score updated:', oldScore, '‚Üí', siteData.trustScore);\n        // Update data flow visualization\n        this.updateDataFlow(siteData, sourceDomain, trackerDomain);\n        this.siteData.set(sourceDomain, siteData);\n    }\n    isTrackerBlocked(domain) {\n        // Check if domain is in our blocking rules\n        const blockedDomains = ['doubleclick.net', 'googletagmanager.com', 'facebook.com/tr'];\n        return blockedDomains.some(blocked => domain.includes(blocked));\n    }\n    updateDataFlow(siteData, source, tracker) {\n        // Add nodes if they don't exist\n        if (!siteData.dataFlow.nodes.find(n => n.id === source)) {\n            siteData.dataFlow.nodes.push({\n                id: source,\n                domain: source,\n                type: 'source',\n                position: { x: 100, y: 100 }\n            });\n        }\n        if (!siteData.dataFlow.nodes.find(n => n.id === tracker)) {\n            const nodeCount = siteData.dataFlow.nodes.length;\n            siteData.dataFlow.nodes.push({\n                id: tracker,\n                domain: tracker,\n                type: 'tracker',\n                position: { x: 200 + (nodeCount * 100), y: 150 }\n            });\n        }\n        // Add edge if it doesn't exist\n        if (!siteData.dataFlow.edges.find(e => e.from === source && e.to === tracker)) {\n            siteData.dataFlow.edges.push({\n                from: source,\n                to: tracker,\n                dataType: 'user_data'\n            });\n        }\n    }\n    initializeSiteData(url) {\n        const domain = this.getDomainFromURL(url);\n        if (!domain) {\n            console.warn('‚ùå Cannot initialize site data for invalid URL:', url);\n            return;\n        }\n        console.log('üè† Initializing site data for:', domain);\n        if (!this.siteData.has(domain)) {\n            const newSiteData = {\n                url,\n                trustScore: 100,\n                trackers: [],\n                dataFlow: {\n                    nodes: [],\n                    edges: []\n                }\n            };\n            this.siteData.set(domain, newSiteData);\n            console.log('‚úÖ Site data initialized:', newSiteData);\n        }\n        else {\n            console.log('‚ôªÔ∏è Site data already exists for:', domain);\n        }\n    }\n    initializeSiteDataForDomain(domain) {\n        console.log('üè† Initializing site data for domain:', domain);\n        if (!this.siteData.has(domain)) {\n            const newSiteData = {\n                url: `https://${domain}`, // Construct basic URL from domain\n                trustScore: 100,\n                trackers: [],\n                dataFlow: {\n                    nodes: [],\n                    edges: []\n                }\n            };\n            this.siteData.set(domain, newSiteData);\n            console.log('‚úÖ Site data initialized for domain:', newSiteData);\n        }\n        else {\n            console.log('‚ôªÔ∏è Site data already exists for domain:', domain);\n        }\n    }\n    async getSiteData(url) {\n        const domain = this.getDomainFromURL(url);\n        if (!domain) {\n            console.warn('‚ùå Cannot get site data for invalid URL:', url);\n            return null;\n        }\n        // Ensure site data exists for this domain\n        if (!this.siteData.has(domain)) {\n            console.log('üîÑ Site data not found, initializing for:', domain);\n            this.initializeSiteData(url);\n        }\n        const siteData = this.siteData.get(domain) || null;\n        console.log('üìä Getting site data for:', domain, 'Found:', !!siteData, 'Trackers:', siteData?.trackers?.length || 0);\n        return siteData;\n    }\n    async toggleTrackerBlocking(enabled) {\n        // Toggle declarative net request rules\n        const ruleIds = [1, 2, 3, 4, 5]; // IDs from rules.json\n        if (enabled) {\n            await chrome.declarativeNetRequest.updateEnabledRulesets({\n                enableRulesetIds: ['tracker_rules']\n            });\n        }\n        else {\n            await chrome.declarativeNetRequest.updateEnabledRulesets({\n                disableRulesetIds: ['tracker_rules']\n            });\n        }\n    }\n    setupMessageListeners() {\n        chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n            console.log('üì® Message received:', request.action, request);\n            switch (request.action) {\n                case 'getSiteData':\n                    this.getSiteData(request.url).then(sendResponse);\n                    return true;\n                case 'getFingerprintScript':\n                    this.getFingerprintScript(request.apiKey).then(sendResponse);\n                    return true;\n                case 'toggleBlocking':\n                    this.toggleTrackerBlocking(request.enabled).then(() => {\n                        sendResponse({ success: true });\n                    });\n                    return true;\n                case 'analyzePrivacyPolicy':\n                    this.analyzePrivacyPolicy(request.url).then(sendResponse);\n                    return true;\n                case 'privacyPoliciesFound':\n                    this.storePrivacyPolicyUrls(request.currentUrl, request.urls);\n                    sendResponse({ success: true });\n                    return true;\n                case 'debugInfo':\n                    // Return debug information\n                    const debugInfo = {\n                        trackedDomains: Array.from(this.siteData.keys()),\n                        totalSites: this.siteData.size,\n                        siteDataSnapshot: Array.from(this.siteData.entries()).map(([domain, data]) => ({\n                            domain,\n                            trackerCount: data.trackers.length,\n                            trustScore: data.trustScore\n                        }))\n                    };\n                    console.log('üêõ Debug info requested:', debugInfo);\n                    sendResponse(debugInfo);\n                    return true;\n                case 'runFingerprint':\n                    if (request.tabId) {\n                        this.handleFingerprinting(request.apiKey, request.tabId)\n                            .then(sendResponse)\n                            .catch(error => sendResponse({ success: false, error: error.message }));\n                    }\n                    else {\n                        sendResponse({ success: false, error: 'No tabId provided in the request.' });\n                    }\n                    return true; // Keep channel open for async response\n                case 'performOptOut':\n                    this.performComprehensiveOptOut(request.url, request.tabId)\n                        .then(sendResponse)\n                        .catch((error) => sendResponse({ success: false, error: error.message }));\n                    return true;\n            }\n        });\n    }\n    storePrivacyPolicyUrls(siteUrl, policyUrls) {\n        const domain = this.getDomainFromURL(siteUrl);\n        if (!domain) {\n            console.warn('‚ùå Cannot store privacy policy URLs for invalid URL:', siteUrl);\n            return;\n        }\n        this.privacyPolicyUrls.set(domain, policyUrls);\n    }\n    async analyzePrivacyPolicy(siteUrl) {\n        const domain = this.getDomainFromURL(siteUrl);\n        if (!domain) {\n            console.warn('‚ùå Cannot analyze privacy policy for invalid URL:', siteUrl);\n            return { error: 'Invalid URL provided' };\n        }\n        console.log('ü§ñ Starting real-time privacy policy analysis for:', siteUrl);\n        try {\n            // First, try enhanced analysis with Apify + Gemini\n            const enhancedAnalysis = await this.callBackendAPI('/api/privacy-policy/analyze-enhanced', {\n                url: siteUrl\n            });\n            if (enhancedAnalysis.success) {\n                console.log('‚úÖ Enhanced analysis completed successfully');\n                return this.formatAnalysisResponse(enhancedAnalysis.data, 'enhanced');\n            }\n            // Fallback to standard analysis if enhanced fails\n            console.log('‚ö†Ô∏è Enhanced analysis failed, trying standard analysis...');\n            const standardAnalysis = await this.callBackendAPI('/api/privacy-policy/analyze', {\n                url: siteUrl,\n                enhanced: false\n            });\n            if (standardAnalysis.success) {\n                console.log('‚úÖ Standard analysis completed successfully');\n                return this.formatAnalysisResponse(standardAnalysis.data, 'standard');\n            }\n            // If backend is unavailable, use fallback analysis\n            console.log('‚ö†Ô∏è Backend unavailable, using fallback analysis...');\n            return await this.fallbackPrivacyAnalysis(siteUrl);\n        }\n        catch (error) {\n            console.error('‚ùå Privacy policy analysis failed:', error);\n            return await this.fallbackPrivacyAnalysis(siteUrl);\n        }\n    }\n    async callBackendAPI(endpoint, data) {\n        const BACKEND_URL = 'http://localhost:3000';\n        try {\n            const response = await fetch(`${BACKEND_URL}${endpoint}`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(data)\n            });\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            return await response.json();\n        }\n        catch (error) {\n            console.error(`Backend API call failed for ${endpoint}:`, error);\n            throw error;\n        }\n    }\n    formatAnalysisResponse(backendData, analysisType) {\n        // Convert backend response to extension format\n        const score = this.calculateScoreFromSafety(backendData.safety, backendData.scores);\n        return {\n            score,\n            risks: this.extractRisks(backendData),\n            summary: backendData.summary || 'Privacy policy analysis completed',\n            dataSharing: this.extractDataSharing(backendData),\n            recommendations: this.generateRecommendations(backendData),\n            complianceStatus: this.assessCompliance(backendData),\n            analysisType,\n            keyFindings: backendData.keyFindings || [],\n            scores: backendData.scores || {},\n            metadata: backendData.policyMetadata || {}\n        };\n    }\n    calculateScoreFromSafety(safety, scores) {\n        // Base score from safety rating\n        let baseScore = 50;\n        switch (safety) {\n            case 'SAFE':\n                baseScore = 85;\n                break;\n            case 'RISKY':\n                baseScore = 50;\n                break;\n            case 'UNSAFE':\n                baseScore = 20;\n                break;\n        }\n        // Adjust with detailed scores if available\n        if (scores) {\n            const avgScore = ((scores.dataCollection || 50) +\n                (scores.thirdParty || 50) +\n                (scores.userRights || 50) +\n                (scores.transparency || 50)) / 4;\n            // Weighted average: 60% detailed scores, 40% safety rating\n            return Math.round((avgScore * 0.6) + (baseScore * 0.4));\n        }\n        return baseScore;\n    }\n    extractRisks(data) {\n        const risks = [];\n        if (data.safety === 'UNSAFE') {\n            risks.push('High privacy risk detected');\n        }\n        else if (data.safety === 'RISKY') {\n            risks.push('Moderate privacy concerns identified');\n        }\n        if (data.scores) {\n            if (data.scores.dataCollection < 50) {\n                risks.push('Extensive data collection practices');\n            }\n            if (data.scores.thirdParty < 50) {\n                risks.push('Significant third-party data sharing');\n            }\n            if (data.scores.userRights < 50) {\n                risks.push('Limited user control and rights');\n            }\n            if (data.scores.transparency < 50) {\n                risks.push('Unclear or vague privacy policy');\n            }\n        }\n        if (data.keyFindings) {\n            data.keyFindings.forEach((finding) => {\n                if (finding.toLowerCase().includes('concern') ||\n                    finding.toLowerCase().includes('risk') ||\n                    finding.toLowerCase().includes('issue')) {\n                    risks.push(finding);\n                }\n            });\n        }\n        return risks.length > 0 ? risks : ['Analysis completed without major concerns'];\n    }\n    extractDataSharing(data) {\n        const dataSharing = [];\n        if (data.keyFindings) {\n            data.keyFindings.forEach((finding) => {\n                if (finding.toLowerCase().includes('google') ||\n                    finding.toLowerCase().includes('facebook') ||\n                    finding.toLowerCase().includes('analytics') ||\n                    finding.toLowerCase().includes('advertising') ||\n                    finding.toLowerCase().includes('third party') ||\n                    finding.toLowerCase().includes('partners')) {\n                    dataSharing.push(finding);\n                }\n            });\n        }\n        // Default common trackers if none found\n        if (dataSharing.length === 0) {\n            dataSharing.push('Analytics services', 'Advertising networks');\n        }\n        return dataSharing;\n    }\n    generateRecommendations(data) {\n        const recommendations = [];\n        if (data.scores) {\n            if (data.scores.userRights < 70) {\n                recommendations.push('Review your privacy settings');\n                recommendations.push('Consider opting out of data sharing');\n            }\n            if (data.scores.transparency < 70) {\n                recommendations.push('Read the full privacy policy carefully');\n            }\n            if (data.scores.thirdParty < 60) {\n                recommendations.push('Use privacy-focused browser settings');\n                recommendations.push('Consider using tracking protection');\n            }\n        }\n        if (data.safety === 'UNSAFE') {\n            recommendations.push('Avoid sharing sensitive information');\n            recommendations.push('Use alternative services if possible');\n        }\n        return recommendations.length > 0 ? recommendations : ['Enable privacy protection features'];\n    }\n    assessCompliance(data) {\n        // Basic compliance assessment based on analysis\n        const compliance = {\n            gdpr: 'unclear',\n            ccpa: 'unclear',\n            coppa: 'unclear'\n        };\n        if (data.keyFindings) {\n            const findings = data.keyFindings.join(' ').toLowerCase();\n            if (findings.includes('gdpr') || findings.includes('data protection')) {\n                compliance.gdpr = data.scores?.userRights > 70 ? 'compliant' : 'partial';\n            }\n            if (findings.includes('ccpa') || findings.includes('california')) {\n                compliance.ccpa = data.scores?.userRights > 70 ? 'compliant' : 'partial';\n            }\n            if (findings.includes('children') || findings.includes('coppa')) {\n                compliance.coppa = data.scores?.dataCollection > 80 ? 'compliant' : 'non-compliant';\n            }\n        }\n        return compliance;\n    }\n    async fallbackPrivacyAnalysis(siteUrl) {\n        const domain = this.getDomainFromURL(siteUrl);\n        if (!domain) {\n            return { error: 'Invalid URL provided' };\n        }\n        const policyUrls = this.privacyPolicyUrls.get(domain) || [];\n        // If no privacy policy URLs found, try to find them with enhanced detection\n        if (policyUrls.length === 0) {\n            // Expanded list of common privacy policy paths\n            const commonPaths = [\n                '/privacy',\n                '/privacy-policy',\n                '/privacy.html',\n                '/privacy.php',\n                '/privacy.aspx',\n                '/terms',\n                '/terms-of-service',\n                '/terms-and-conditions',\n                '/legal/privacy',\n                '/legal/terms',\n                '/help/privacy',\n                '/support/privacy',\n                '/about/privacy',\n                '/policies/privacy',\n                '/privacy-statement',\n                '/privacy-notice',\n                '/data-protection',\n                '/cookie-policy',\n                '/gdpr',\n                '/ccpa'\n            ];\n            // Try multiple variations with different protocols and subdomains\n            const urlVariations = [\n                `https://${domain}`,\n                `https://www.${domain}`,\n                `http://${domain}`,\n                `http://www.${domain}`\n            ];\n            for (const baseUrl of urlVariations) {\n                for (const path of commonPaths) {\n                    try {\n                        // Use AbortController for timeout\n                        const controller = new AbortController();\n                        const timeoutId = setTimeout(() => controller.abort(), 5000);\n                        const response = await fetch(`${baseUrl}${path}`, {\n                            method: 'HEAD', // Use HEAD request for faster checking\n                            signal: controller.signal\n                        });\n                        clearTimeout(timeoutId);\n                        if (response.ok) {\n                            policyUrls.push(`${baseUrl}${path}`);\n                            break; // Found one, move to next base URL\n                        }\n                    }\n                    catch (e) {\n                        // Continue to next path\n                    }\n                }\n                if (policyUrls.length > 0)\n                    break; // Found policy, stop searching\n            }\n        }\n        if (policyUrls.length === 0) {\n            return {\n                score: 50,\n                risks: ['No privacy policy found'],\n                summary: 'Unable to locate a privacy policy for this website.',\n                dataSharing: [],\n                recommendations: ['Look for privacy information in website footer'],\n                complianceStatus: { gdpr: 'unclear', ccpa: 'unclear', coppa: 'unclear' },\n                analysisType: 'fallback'\n            };\n        }\n        // Fetch and analyze the privacy policy with basic analysis\n        try {\n            const policyText = await this.fetchPrivacyPolicyText(policyUrls[0]);\n            const analysis = await this.performBasicPrivacyAnalysis(policyText, domain);\n            // Store the analysis in site data\n            const siteData = this.siteData.get(domain);\n            if (siteData) {\n                siteData.privacyAnalysis = analysis;\n                this.siteData.set(domain, siteData);\n            }\n            return analysis;\n        }\n        catch (error) {\n            console.error('Fallback privacy policy analysis failed:', error);\n            return {\n                score: 30,\n                risks: ['Failed to analyze privacy policy'],\n                summary: 'Privacy policy analysis encountered an error.',\n                dataSharing: [],\n                recommendations: ['Manual review recommended'],\n                complianceStatus: { gdpr: 'unclear', ccpa: 'unclear', coppa: 'unclear' },\n                analysisType: 'fallback'\n            };\n        }\n    }\n    async performBasicPrivacyAnalysis(policyText, domain) {\n        // Basic analysis without AI - simplified version\n        const textLower = policyText.toLowerCase();\n        let score = 70; // Start with neutral score\n        const risks = [];\n        const dataSharing = [];\n        // Check for common privacy concerns\n        if (textLower.includes('third party') || textLower.includes('partners')) {\n            score -= 10;\n            risks.push('Data may be shared with third parties');\n            dataSharing.push('Third-party partners');\n        }\n        if (textLower.includes('cookies') || textLower.includes('tracking')) {\n            dataSharing.push('Tracking cookies');\n        }\n        if (textLower.includes('advertising') || textLower.includes('marketing')) {\n            score -= 5;\n            dataSharing.push('Advertising partners');\n        }\n        if (textLower.includes('google analytics') || textLower.includes('analytics')) {\n            dataSharing.push('Google Analytics');\n        }\n        // Check for positive indicators\n        if (textLower.includes('gdpr') || textLower.includes('data protection')) {\n            score += 10;\n        }\n        if (textLower.includes('opt out') || textLower.includes('opt-out')) {\n            score += 5;\n        }\n        return {\n            score: Math.max(20, Math.min(100, score)),\n            risks: risks.length > 0 ? risks : ['Standard data collection practices'],\n            summary: 'Basic privacy policy analysis completed',\n            dataSharing: dataSharing.length > 0 ? dataSharing : ['Standard website analytics'],\n            recommendations: score < 50 ? ['Review privacy settings', 'Consider opt-out options'] : ['Standard privacy recommendations'],\n            complianceStatus: { gdpr: 'unclear', ccpa: 'unclear', coppa: 'unclear' },\n            analysisType: 'basic'\n        };\n    }\n    async fetchPrivacyPolicyText(policyUrl) {\n        try {\n            const response = await fetch(policyUrl);\n            const html = await response.text();\n            // Remove script and style tags\n            let cleanHtml = html.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '');\n            cleanHtml = cleanHtml.replace(/<style\\b[^<]*(?:(?!<\\/style>)<[^<]*)*<\\/style>/gi, '');\n            // Remove all HTML tags and decode entities\n            let textContent = cleanHtml.replace(/<[^>]*>/g, ' ');\n            // Decode common HTML entities\n            textContent = textContent.replace(/&nbsp;/g, ' ')\n                .replace(/&amp;/g, '&')\n                .replace(/&lt;/g, '<')\n                .replace(/&gt;/g, '>')\n                .replace(/&quot;/g, '\"')\n                .replace(/&#39;/g, \"'\");\n            // Clean up whitespace\n            textContent = textContent.replace(/\\s+/g, ' ').trim();\n            return textContent;\n        }\n        catch (error) {\n            console.error('Failed to fetch privacy policy:', policyUrl, error);\n            throw new Error(`Failed to fetch privacy policy: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n    async performPrivacyAnalysis(policyText, domain) {\n        const text = policyText.toLowerCase();\n        const risks = [];\n        const dataSharing = [];\n        let score = 80; // Start with a higher base score\n        // Enhanced risk detection with more sophisticated patterns\n        const riskPatterns = {\n            'Data Selling': {\n                keywords: ['sell', 'sale', 'sold', 'monetize', 'revenue from data', 'third-party purchasers'],\n                penalty: 25,\n                context: ['personal information', 'user data', 'your data']\n            },\n            'Cross-site Tracking': {\n                keywords: ['track across', 'follow you', 'behavioral tracking', 'cross-site', 'cross-platform'],\n                penalty: 20,\n                context: ['websites', 'platforms', 'services']\n            },\n            'Vague Data Retention': {\n                keywords: ['indefinitely', 'as long as necessary', 'business purposes', 'legal requirements'],\n                penalty: 15,\n                context: ['retain', 'keep', 'store', 'maintain']\n            },\n            'Limited User Control': {\n                keywords: ['cannot delete', 'unable to remove', 'permanent', 'irrevocable'],\n                penalty: 20,\n                context: ['account', 'data', 'information']\n            },\n            'Broad Data Collection': {\n                keywords: ['all information', 'any data', 'everything', 'comprehensive'],\n                penalty: 15,\n                context: ['collect', 'gather', 'obtain']\n            },\n            'Weak Consent Mechanisms': {\n                keywords: ['deemed consent', 'implied consent', 'continued use', 'by using'],\n                penalty: 18,\n                context: ['agree', 'consent', 'acceptance']\n            },\n            'Data Sharing with Law Enforcement': {\n                keywords: ['law enforcement', 'government agencies', 'legal process', 'subpoena'],\n                penalty: 10,\n                context: ['share', 'provide', 'disclose']\n            },\n            'Location Tracking': {\n                keywords: ['precise location', 'gps', 'geolocation', 'whereabouts'],\n                penalty: 15,\n                context: ['track', 'collect', 'monitor']\n            },\n            'Biometric Data Collection': {\n                keywords: ['biometric', 'fingerprint', 'facial recognition', 'voice print'],\n                penalty: 20,\n                context: ['collect', 'process', 'store']\n            },\n            'Children Data Collection': {\n                keywords: ['under 13', 'children', 'minors', 'parental consent'],\n                penalty: 25,\n                context: ['collect', 'process', 'target']\n            }\n        };\n        // Check for risks with context awareness\n        for (const [riskName, config] of Object.entries(riskPatterns)) {\n            const hasKeywords = config.keywords.some(keyword => text.includes(keyword));\n            const hasContext = config.context.some(context => text.includes(context));\n            if (hasKeywords && hasContext) {\n                risks.push(riskName);\n                score -= config.penalty;\n            }\n        }\n        // Enhanced data sharing detection\n        const sharingEntities = {\n            'Google': ['google', 'alphabet', 'youtube', 'gmail', 'google analytics', 'doubleclick'],\n            'Meta/Facebook': ['facebook', 'meta', 'instagram', 'whatsapp', 'messenger'],\n            'Amazon': ['amazon', 'aws', 'amazon web services', 'alexa'],\n            'Microsoft': ['microsoft', 'office 365', 'azure', 'bing'],\n            'Apple': ['apple', 'icloud', 'itunes', 'app store'],\n            'TikTok/ByteDance': ['tiktok', 'bytedance'],\n            'Twitter/X': ['twitter', 'x corp'],\n            'Advertising Networks': ['adsense', 'admob', 'advertising partners', 'ad networks'],\n            'Analytics Providers': ['analytics', 'tracking', 'measurement', 'statistics'],\n            'Data Brokers': ['data broker', 'information broker', 'third-party data'],\n            'Marketing Partners': ['marketing partners', 'promotional partners', 'affiliates'],\n            'Government Agencies': ['government', 'law enforcement', 'regulatory agencies']\n        };\n        for (const [entity, keywords] of Object.entries(sharingEntities)) {\n            const mentioned = keywords.some(keyword => text.includes(keyword));\n            if (mentioned && !dataSharing.includes(entity)) {\n                dataSharing.push(entity);\n            }\n        }\n        // Positive privacy practices (score bonuses)\n        const positivePatterns = [\n            { keywords: ['opt-out', 'opt out'], bonus: 8, description: 'Clear opt-out mechanisms' },\n            { keywords: ['delete account', 'data deletion'], bonus: 10, description: 'Account deletion available' },\n            { keywords: ['anonymize', 'anonymization'], bonus: 6, description: 'Data anonymization' },\n            { keywords: ['encryption', 'encrypted'], bonus: 8, description: 'Data encryption' },\n            { keywords: ['minimal data', 'data minimization'], bonus: 12, description: 'Data minimization principle' },\n            { keywords: ['user control', 'user choice'], bonus: 8, description: 'User control emphasized' },\n            { keywords: ['transparent', 'transparency'], bonus: 6, description: 'Transparency commitment' },\n            { keywords: ['third-party audits', 'security audits'], bonus: 10, description: 'Security auditing' },\n            { keywords: ['gdpr', 'ccpa', 'privacy rights'], bonus: 12, description: 'Privacy law compliance' }\n        ];\n        const positiveFeatures = [];\n        for (const pattern of positivePatterns) {\n            const hasPositive = pattern.keywords.some(keyword => text.includes(keyword));\n            if (hasPositive) {\n                score += pattern.bonus;\n                positiveFeatures.push(pattern.description);\n            }\n        }\n        // Industry-specific risk assessment\n        const industryRisks = {\n            'Social Media': ['social', 'posts', 'friends', 'connections'],\n            'E-commerce': ['purchase', 'shopping', 'payment', 'transactions'],\n            'Financial': ['financial', 'banking', 'credit', 'loan'],\n            'Healthcare': ['health', 'medical', 'patient', 'treatment'],\n            'Education': ['student', 'academic', 'education', 'learning']\n        };\n        let industryType = 'General';\n        for (const [industry, keywords] of Object.entries(industryRisks)) {\n            const isIndustry = keywords.some(keyword => text.includes(keyword));\n            if (isIndustry) {\n                industryType = industry;\n                // Apply industry-specific scoring adjustments\n                if (industry === 'Financial' || industry === 'Healthcare') {\n                    score -= 5; // Higher standards for sensitive industries\n                }\n                break;\n            }\n        }\n        // Ensure score stays within bounds\n        score = Math.max(0, Math.min(100, score));\n        // Generate enhanced summary\n        let summary = `This ${industryType.toLowerCase()} privacy policy has been analyzed for comprehensive privacy practices. `;\n        if (score >= 80) {\n            summary += 'The policy demonstrates strong privacy protection with clear user rights, limited data sharing, and transparent practices.';\n        }\n        else if (score >= 60) {\n            summary += 'The policy shows reasonable privacy practices but has some areas of concern regarding data collection or sharing.';\n        }\n        else if (score >= 40) {\n            summary += 'The policy has significant privacy concerns with extensive data collection, sharing, or unclear user rights.';\n        }\n        else {\n            summary += 'The policy raises serious privacy concerns with poor user protection, extensive data sharing, or lack of user control.';\n        }\n        if (positiveFeatures.length > 0) {\n            summary += ` Positive aspects include: ${positiveFeatures.slice(0, 3).join(', ')}.`;\n        }\n        return {\n            score,\n            risks: risks.slice(0, 8), // Limit to most important risks\n            summary,\n            dataSharing: [...new Set(dataSharing)].slice(0, 8), // Remove duplicates and limit\n            industryType,\n            positiveFeatures: positiveFeatures.slice(0, 5),\n            analysisDepth: 'Enhanced AI Analysis',\n            lastAnalyzed: new Date().toISOString()\n        };\n    }\n    async getFingerprintScript(apiKey) {\n        const loaderUrl = `https://fpnpmcdn.net/v3/${apiKey}/loader_v3.11.10.js`;\n        try {\n            const response = await fetch(loaderUrl);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch script: ${response.statusText}`);\n            }\n            const script = await response.text();\n            return { script };\n        }\n        catch (error) {\n            console.error('Failed to fetch FingerprintJS script:', error);\n            return { error: error.message };\n        }\n    }\n    async handleFingerprinting(apiKey, tabId) {\n        try {\n            // Inject the bundled fingerprinting script into the active tab's main world\n            await chrome.scripting.executeScript({\n                target: { tabId: tabId },\n                files: ['fingerprint-agent.js'],\n                world: 'MAIN'\n            });\n            // Now execute the code to run FingerprintJS in the main world\n            const results = await chrome.scripting.executeScript({\n                target: { tabId: tabId },\n                func: runFingerprintJS,\n                args: [apiKey],\n                world: 'MAIN'\n            });\n            if (results && results[0] && results[0].result) {\n                return results[0].result;\n            }\n            else {\n                throw new Error('No result returned from fingerprinting script');\n            }\n        }\n        catch (error) {\n            console.error('Background fingerprinting error:', error);\n            return {\n                success: false,\n                error: `Failed to run fingerprinting: ${error.message}`\n            };\n        }\n    }\n    async performComprehensiveOptOut(url, tabId) {\n        try {\n            const domain = this.getDomainFromURL(url);\n            if (!domain) {\n                throw new Error('Invalid URL provided');\n            }\n            console.log('üö´ Starting comprehensive opt-out for:', domain);\n            // Step 1: Update tracking rules to block this domain\n            await this.addDomainToBlockList(domain);\n            // Step 2: Clear all request tracking for this domain\n            this.clearDomainTrackingData(domain);\n            // Step 3: Block all future third-party requests from this domain\n            await this.enableEnhancedBlockingForDomain(domain);\n            // Step 4: Clear any stored privacy policy data\n            this.privacyPolicyUrls.delete(domain);\n            // Step 5: Mark domain as opted out\n            await chrome.storage.local.set({\n                [`optedOut_${domain}`]: {\n                    timestamp: Date.now(),\n                    userInitiated: true,\n                    comprehensive: true\n                }\n            });\n            // Step 6: Reset trust score to reflect opt-out status\n            const siteData = this.siteData.get(domain);\n            if (siteData) {\n                siteData.trustScore = 95; // High score due to opt-out\n                siteData.trackers = []; // Clear tracked requests\n                this.siteData.set(domain, siteData);\n            }\n            console.log('‚úÖ Background opt-out processing completed for:', domain);\n            return {\n                success: true,\n                message: `Comprehensive opt-out completed for ${domain}`\n            };\n        }\n        catch (error) {\n            console.error('‚ùå Background opt-out failed:', error);\n            return {\n                success: false,\n                error: `Opt-out failed: ${error.message}`\n            };\n        }\n    }\n    async addDomainToBlockList(domain) {\n        try {\n            // Get existing blocked domains\n            const storage = await chrome.storage.local.get(['blockedDomains']);\n            const blockedDomains = storage.blockedDomains || [];\n            if (!blockedDomains.includes(domain)) {\n                blockedDomains.push(domain);\n                await chrome.storage.local.set({ blockedDomains });\n                console.log('üìù Added domain to block list:', domain);\n            }\n        }\n        catch (error) {\n            console.warn('Failed to add domain to block list:', error);\n        }\n    }\n    clearDomainTrackingData(domain) {\n        try {\n            // Remove from site data\n            this.siteData.delete(domain);\n            // Clear blocked requests count\n            const keysToDelete = Array.from(this.blockedRequests.keys())\n                .filter(key => key.includes(domain));\n            keysToDelete.forEach(key => this.blockedRequests.delete(key));\n            console.log('üßπ Cleared tracking data for:', domain);\n        }\n        catch (error) {\n            console.warn('Failed to clear domain tracking data:', error);\n        }\n    }\n    async enableEnhancedBlockingForDomain(domain) {\n        try {\n            // Create dynamic rules to block requests from this domain\n            const newRules = [\n                {\n                    id: Date.now(),\n                    priority: 1,\n                    action: { type: 'block' },\n                    condition: {\n                        initiatorDomains: [domain],\n                        resourceTypes: [\n                            'script',\n                            'xmlhttprequest',\n                            'image',\n                            'media',\n                            'font',\n                            'websocket'\n                        ]\n                    }\n                }\n            ];\n            // YouTube-specific blocking rules\n            if (domain.includes('youtube.com') || domain.includes('google.com')) {\n                newRules.push({\n                    id: Date.now() + 1,\n                    priority: 2,\n                    action: { type: 'block' },\n                    condition: {\n                        urlFilter: '*youtube.com/api/stats*',\n                        resourceTypes: ['xmlhttprequest']\n                    }\n                }, {\n                    id: Date.now() + 2,\n                    priority: 2,\n                    action: { type: 'block' },\n                    condition: {\n                        urlFilter: '*youtube.com/youtubei/v1/log_event*',\n                        resourceTypes: ['xmlhttprequest']\n                    }\n                }, {\n                    id: Date.now() + 3,\n                    priority: 2,\n                    action: { type: 'block' },\n                    condition: {\n                        urlFilter: '*youtube.com/ptracking*',\n                        resourceTypes: ['xmlhttprequest', 'image']\n                    }\n                });\n            }\n            await chrome.declarativeNetRequest.updateDynamicRules({\n                addRules: newRules\n            });\n            console.log('üõ°Ô∏è Enhanced blocking enabled for:', domain);\n        }\n        catch (error) {\n            console.warn('Failed to enable enhanced blocking:', error);\n        }\n    }\n}\n// This function gets injected into the webpage after the agent is injected\nfunction runFingerprintJS(apiKey) {\n    return new Promise((resolve) => {\n        // The FingerprintJS object is now available on the window\n        // thanks to the injected fingerprint-agent.js script.\n        async function initializeFingerprint() {\n            try {\n                const fp = await window.FingerprintJS.load({\n                    apiKey: apiKey,\n                    region: 'ap'\n                });\n                const result = await fp.get({\n                    extendedResult: true\n                });\n                resolve({\n                    success: true,\n                    data: {\n                        visitorId: result.visitorId,\n                        confidence: result.confidence,\n                        components: result.components,\n                        requestId: result.requestId,\n                        timestamp: Date.now()\n                    }\n                });\n            }\n            catch (error) {\n                resolve({\n                    success: false,\n                    error: `Fingerprinting failed: ${error.message}`\n                });\n            }\n        }\n        // Wait for the FingerprintJS object to be available\n        let checks = 0;\n        const interval = setInterval(() => {\n            checks++;\n            if (window.FingerprintJS) {\n                clearInterval(interval);\n                initializeFingerprint();\n            }\n            else if (checks > 50) { // Timeout after 5 seconds\n                clearInterval(interval);\n                resolve({ success: false, error: 'FingerprintJS object not found after script injection.' });\n            }\n        }, 100);\n    });\n}\nconst backgroundService = new BackgroundService();\n"],"names":[],"sourceRoot":""}